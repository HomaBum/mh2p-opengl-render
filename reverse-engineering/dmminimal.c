/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void init_proc();
// int __fastcall glGetShaderiv(_DWORD, _DWORD, _DWORD); weak
// int __fastcall glVertexAttribPointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall eglDestroySurface(_DWORD); weak
// int __fastcall Stoul(_DWORD, _DWORD, _DWORD); weak
// int __fastcall glEnableVertexAttribArray(_DWORD); weak
// int __fastcall _deregister_frame_info(_DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __fastcall glCompileShader(_DWORD); weak
// __pid_t getpid(void);
// int glCreateProgram(void); weak
// int __fastcall init_array(_DWORD, _DWORD); weak
// void *malloc(size_t size);
// int __fastcall glCreateShader(_DWORD); weak
// int __fastcall glDeleteShader(_DWORD); weak
// int __fastcall eglCreateContext(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall glGetProgramInfoLog(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall preinit_array(_DWORD, _DWORD); weak
// int __fastcall glShaderSource(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall init_libc(_DWORD); weak
// int printf(const char *format, ...);
int __fastcall swapBuffers(int, int);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __fastcall eglCreateWindowSurface(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall glBindAttribLocation(_DWORD, _DWORD, _DWORD); weak
// int __fastcall _cxa_finalize(void *);
// int eglTerminate(void); weak
// int __fastcall _register_frame_info(_DWORD, _DWORD); weak
// int __fastcall eglDestroyContext(_DWORD); weak
// void exit(int status);
// int fprintf(FILE *stream, const char *format, ...);
// void glDrawArrays(GLenum mode, GLint first, GLsizei count);
// void glClear(GLbitfield mask);
// int __fastcall eglChooseConfig(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
// int __fastcall dint_destroy_window(_DWORD); weak
// int __fastcall eglInitialize(_DWORD, _DWORD, _DWORD); weak
// int __fastcall fini_array(_DWORD, _DWORD); weak
// void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
int __fastcall deinit_dint(int);
// int __fastcall dint_deinit();
// int eglGetDisplay(void); weak
// int atexit(void (*func)(void));
// int __fastcall dint_create_window(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall glGetProgramiv(_DWORD, _DWORD, _DWORD); weak
// void free(void *ptr);
// int __fastcall eglMakeCurrent(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall dint_get_native_window(_DWORD, _DWORD); weak
// int dint_init(void); weak
// int __fastcall glUseProgram(_DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall glDeleteProgram(_DWORD); weak
// int __fastcall glLinkProgram(_DWORD); weak
// int __fastcall glAttachShader(_DWORD, _DWORD); weak
// int __fastcall glGetShaderInfoLog(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl main(int argc, const char **argv, const char **envp);
void __noreturn start(int, int, int, int, int, ...);
char *sub_111C();
__int64 sub_115C();
char *__fastcall sub_11A0(int a1, int a2, int a3, int a4);
__int64 __fastcall sub_11F8(int a1, int a2, int a3, int a4);
int __fastcall stopHandler(int result);
int __fastcall compileShader(int, int);
int createGlProgram();
int render();
int initWindow();
int closeWindow();
void term_proc();
// int __fastcall __cxa_finalize(void *);
// int __fastcall Jv_RegisterClasses(_DWORD); weak
// int ITM_deregisterTMCloneTable(void); weak
// int ITM_registerTMCloneTable(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN _exidx_start; // weak
void *off_2DB0 = (void *)0x11F9; // weak
void *off_2DB4 = (void *)0x11A1; // weak
int dword_2DB8 = 0; // weak
void *_data_start = &_data_start; // weak
_UNKNOWN unk_3004; // weak
_UNKNOWN unk_3022; // weak
EGL_DEFINES dword_3024 = 0; // weak
_UNKNOWN unk_3031; // weak
_UNKNOWN unk_3032; // weak
_UNKNOWN unk_3034; // weak
_UNKNOWN unk_3040; // weak
int did = 3; // weak
char running = '\x01'; // weak
char byte_306C; // weak
_UNKNOWN unk_3070; // weak
int eglDisplay; // weak
int window; // weak
int eglSurface; // weak
int eglContext; // weak
int glProgram; // weak
// extern _UNKNOWN errno; weak
// extern _UNKNOWN Stderr; weak
// extern _UNKNOWN __deregister_frame_info; weak
// extern _UNKNOWN __register_frame_info; weak


//----- (00000D04) --------------------------------------------------------
void init_proc()
{
  ;
}

//----- (00000FB0) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  __pid_t pid; // r0

  if ( argc == 2 )
    did = Stoul(argv[1], 0, 10);
  pid = getpid();
  printf("my pid: %d\n", pid);
  printf("my did: %d\n", did);
  signal(2, (__sighandler_t)stopHandler);
  if ( !initWindow() || !createGlProgram() )
    return 1;
  do
    render();
  while ( running );
  if ( glProgram )
    glDeleteProgram(glProgram);
  closeWindow();
  return 0;
}
// D44: using guessed type int __fastcall Stoul(_DWORD, _DWORD, _DWORD);
// F74: using guessed type int __fastcall glDeleteProgram(_DWORD);
// 3064: using guessed type int did;
// 3068: using guessed type char running;
// 3098: using guessed type int glProgram;

//----- (00001040) --------------------------------------------------------
void __noreturn start(int a1, int a2, int a3, int a4, int a5, ...)
{
  char *v5; // r3
  int v6; // t1
  int v7; // r0
  va_list va; // [sp+4h] [bp+4h] BYREF

  va_start(va, a5);
  v5 = &(*(char (*)[4])va)[4 * a5 + 4];
  do
  {
    v6 = *(_DWORD *)v5;
    v5 += 4;
  }
  while ( v6 );
  init_libc(a5);
  preinit_array(&off_2DB0, &off_2DB0);
  atexit(term_proc);
  fini_array(&off_2DB4, &dword_2DB8);
  init_proc();
  init_array(&off_2DB0, &off_2DB4);
  errno = 0;
  v7 = main(a5, (const char **)va, (const char **)&(*(char (*)[4])va)[4 * a5 + 4]);
  exit(v7);
}
// D98: using guessed type int __fastcall init_array(_DWORD, _DWORD);
// DE0: using guessed type int __fastcall preinit_array(_DWORD, _DWORD);
// DF8: using guessed type int __fastcall init_libc(_DWORD);
// ED4: using guessed type int __fastcall fini_array(_DWORD, _DWORD);
// 2DB0: using guessed type void *off_2DB0;
// 2DB4: using guessed type void *off_2DB4;
// 2DB8: using guessed type int dword_2DB8;
// 1040: using guessed type char arg_4[4];

//----- (0000111C) --------------------------------------------------------
char *sub_111C()
{
  return &byte_306C;
}
// 306C: using guessed type char byte_306C;
// 3184: using guessed type int ITM_deregisterTMCloneTable(void);

//----- (0000115C) --------------------------------------------------------
__int64 sub_115C()
{
  __int64 result; // r0

  LODWORD(result) = &byte_306C;
  HIDWORD(result) = 0;
  return result;
}
// 306C: using guessed type char byte_306C;
// 318C: using guessed type int ITM_registerTMCloneTable(void);

//----- (000011A0) --------------------------------------------------------
char *__fastcall sub_11A0(int a1, int a2, int a3, int a4)
{
  char *result; // r0

  if ( !byte_306C )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(_data_start);
    result = sub_111C();
    if ( &__deregister_frame_info )
      result = (char *)_deregister_frame_info(&_exidx_start);
    byte_306C = 1;
  }
  return result;
}
// D5C: using guessed type int __fastcall _deregister_frame_info(_DWORD);
// 3000: using guessed type void *_data_start;
// 306C: using guessed type char byte_306C;

//----- (000011F8) --------------------------------------------------------
__int64 __fastcall sub_11F8(int a1, int a2, int a3, int a4)
{
  if ( &__register_frame_info )
    _register_frame_info(&_exidx_start, &unk_3070);
  if ( dword_2DB8 && &Jv_RegisterClasses )
    Jv_RegisterClasses(&dword_2DB8);
  return sub_115C();
}
// E5C: using guessed type int __fastcall _register_frame_info(_DWORD, _DWORD);
// 2DB8: using guessed type int dword_2DB8;
// 3180: using guessed type int __fastcall Jv_RegisterClasses(_DWORD);

//----- (00001248) --------------------------------------------------------
int __fastcall stopHandler(int result)
{
  if ( result == 2 )
    running = 0;
  return result;
}
// 3068: using guessed type char running;

//----- (0000125C) --------------------------------------------------------
int __fastcall compileShader(int a1, int a2)
{
  int Shader; // r0
  int v3; // r4
  int result; // r0
  char *v5; // r8
  int v6; // [sp+4h] [bp-2Ch] BYREF
  int v7; // [sp+Ch] [bp-24h] BYREF
  size_t size; // [sp+10h] [bp-20h] BYREF

  v6 = a2;
  Shader = glCreateShader(a1);
  v3 = Shader;
  if ( !Shader )
    return 0;
  glShaderSource(Shader, 1, &v6, 0);
  glCompileShader(v3);
  glGetShaderiv(v3, 35713, &v7);
  result = v3;
  if ( !v7 )
  {
    size = 0;
    glGetShaderiv(v3, 35716, &size);
    if ( (int)size > 1 )
    {
      v5 = (char *)malloc(size);
      glGetShaderInfoLog(v3, size, 0, v5);
      fprintf((FILE *)&Stderr, "Error compiling shader:\n%s\n", v5);
      free(v5);
    }
    glDeleteShader(v3);
    return 0;
  }
  return result;
}
// D20: using guessed type int __fastcall glGetShaderiv(_DWORD, _DWORD, _DWORD);
// D74: using guessed type int __fastcall glCompileShader(_DWORD);
// DB0: using guessed type int __fastcall glCreateShader(_DWORD);
// DBC: using guessed type int __fastcall glDeleteShader(_DWORD);
// DEC: using guessed type int __fastcall glShaderSource(_DWORD, _DWORD, _DWORD, _DWORD);
// FA4: using guessed type int __fastcall glGetShaderInfoLog(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00001304) --------------------------------------------------------
int createGlProgram()
{
  int v0; // r8
  int v1; // r5
  int Program; // r0
  int v3; // r4
  int v4; // r5
  char *v6; // r9
  int v7; // [sp+0h] [bp-198h] BYREF
  signed int v8; // [sp+4h] [bp-194h] BYREF
  char v9[164]; // [sp+8h] [bp-190h] BYREF
  char dest[200]; // [sp+ACh] [bp-ECh] BYREF

  strcpy(
    dest,
    "attribute vec4 vPosition;    \n"
    "attribute vec4 vColor;\t\t\t\t\n"
    "varying vec4 color;\t\t\t\t\t\n"
    "void main(){                 \n"
    "\t\tcolor = vColor;\t\t\t\t\t\t\n"
    "   gl_Position = vPosition;  \n"
    "}                            \n");
  strcpy(
    v9,
    "precision mediump float;\n"
    "varying vec4 color;\n"
    "void main(){                                 \n"
    "  gl_FragColor = color;\n"
    "}                                            \n");
  v0 = compileShader(0x8B31, (int)dest);
  v1 = compileShader(0x8B30, (int)v9);
  Program = glCreateProgram();
  v3 = Program;
  if ( !Program )
    return 0;
  glAttachShader(Program, v0);
  glAttachShader(v3, v1);
  glBindAttribLocation(v3, 0, "vPosition");
  glBindAttribLocation(v3, 1, "vColor");
  glLinkProgram(v3);
  glGetProgramiv(v3, 0x8B82, &v7);
  v4 = v7;
  if ( v7 )
  {
    v4 = 1;
    glProgram = v3;
    glClearColor(0.0, 0.0, 0.0, 0.0);
  }
  else
  {
    v8 = 0;
    glGetProgramiv(v3, 35716, &v8);
    if ( v8 > 1 )
    {
      v6 = (char *)malloc(v8);
      glGetProgramInfoLog(v3, v8, 0, v6);
      fprintf((FILE *)&Stderr, "Error linking program:\n%s\n", v6);
      free(v6);
    }
    glDeleteProgram(v3);
  }
  return v4;
}
// D8C: using guessed type int glCreateProgram(void);
// DD4: using guessed type int __fastcall glGetProgramInfoLog(_DWORD, _DWORD, _DWORD, _DWORD);
// E38: using guessed type int __fastcall glBindAttribLocation(_DWORD, _DWORD, _DWORD);
// F20: using guessed type int __fastcall glGetProgramiv(_DWORD, _DWORD, _DWORD);
// F74: using guessed type int __fastcall glDeleteProgram(_DWORD);
// F8C: using guessed type int __fastcall glLinkProgram(_DWORD);
// F98: using guessed type int __fastcall glAttachShader(_DWORD, _DWORD);
// 3098: using guessed type int glProgram;

//----- (00001428) --------------------------------------------------------
int render()
{
  glViewport(0, 0, 800, 480);
  glClear(0x4000u);
  glUseProgram(glProgram);
  glVertexAttribPointer(0, 4, 5126, 0, 0, &unk_3034);
  glEnableVertexAttribArray(0);
  glVertexAttribPointer(1, 4, 5126, 0, 0, &unk_3004);
  glEnableVertexAttribArray(1);
  glDrawArrays(4u, 0, 3);
  return swapBuffers(eglDisplay, eglSurface);
}
// D2C: using guessed type int __fastcall glVertexAttribPointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// D50: using guessed type int __fastcall glEnableVertexAttribArray(_DWORD);
// F5C: using guessed type int __fastcall glUseProgram(_DWORD);
// 3088: using guessed type int eglDisplay;
// 3090: using guessed type int eglSurface;
// 3098: using guessed type int glProgram;

//----- (000014BC) --------------------------------------------------------
int initWindow()
{
  int Display; // r0
  int Context; // r0
  int eglConfig; // [sp+8h] [bp-78h] BYREF
  int num_configs; // [sp+Ch] [bp-74h] BYREF
  int native_window; // [sp+10h] [bp-70h] BYREF
  int context_attribs[3]; // [sp+14h] [bp-6Ch] BYREF
  int config_attribs[15]; // [sp+20h] [bp-60h] BYREF

  config_attribs[0] = (int)&dword_3024;
  config_attribs[1] = 8;
  config_attribs[2] = EGL_GREEN_SIZE;
  config_attribs[3] = 8;
  config_attribs[4] = (int)&unk_3022;
  config_attribs[5] = 8;
  config_attribs[6] = EGL_DEPTH_SIZE;
  config_attribs[7] = 16;
  config_attribs[8] = (int)&unk_3032;
  config_attribs[9] = 0;
  config_attribs[10] = (int)&unk_3031;
  config_attribs[11] = 0;
  config_attribs[12] = (int)&unk_3040;
  config_attribs[13] = 4;
  config_attribs[14] = EGL_NONE;
  context_attribs[0] = (int)&glProgram;
  context_attribs[1] = 2;
  context_attribs[2] = EGL_NONE;
  if ( dint_init() )
  {
    fwrite("init of libdisplayinit failed\n", 1u, 0x1Eu, (FILE *)&Stderr);
    return 0;
  }
  else
  {
    Display = eglGetDisplay();
    eglDisplay = Display;
    if ( Display )
    {
      if ( eglInitialize(Display, 0, 0) )
      {
        if ( eglChooseConfig(eglDisplay, config_attribs, &eglConfig, 1, &num_configs) && num_configs )
        {
          if ( dint_create_window(0, 3, 800, 480, 0, &window) )
          {
            fwrite("failed to create window\n", 1u, 0x18u, (FILE *)&Stderr);
            dint_deinit();
            return 0;
          }
          else
          {
            native_window = 0;
            if ( dint_get_native_window(window, &native_window) )
            {
              fwrite("failed to get native window from libdisplayinit\n", 1u, 0x30u, (FILE *)&Stderr);
              return 0;
            }
            else
            {
              eglSurface = eglCreateWindowSurface(eglDisplay, eglConfig, native_window, 0);
              if ( eglSurface )
              {
                Context = eglCreateContext(eglDisplay, eglConfig, 0, context_attribs);
                eglContext = Context;
                if ( Context )
                {
                  if ( eglMakeCurrent(eglDisplay, eglSurface, eglSurface, Context) )
                  {
                    return 1;
                  }
                  else
                  {
                    fwrite("EGL failed to make context/surface current\n", 1u, 0x2Bu, (FILE *)&Stderr);
                    return 0;
                  }
                }
                else
                {
                  fwrite("EGL failed to create context\n", 1u, 0x1Du, (FILE *)&Stderr);
                  return 0;
                }
              }
              else
              {
                fwrite("EGL failed to create window surface\n", 1u, 0x24u, (FILE *)&Stderr);
                return 0;
              }
            }
          }
        }
        else
        {
          fwrite("EGL failed to obtain matching configuration\n", 1u, 0x2Cu, (FILE *)&Stderr);
          return 0;
        }
      }
      else
      {
        fwrite("EGL failed to initialize display\n", 1u, 0x21u, (FILE *)&Stderr);
        return 0;
      }
    }
    else
    {
      fwrite("EGL failed to obtain display\n", 1u, 0x1Du, (FILE *)&Stderr);
      return 0;
    }
  }
}
// DC8: using guessed type int __fastcall eglCreateContext(_DWORD, _DWORD, _DWORD, _DWORD);
// E2C: using guessed type int __fastcall eglCreateWindowSurface(_DWORD, _DWORD, _DWORD, _DWORD);
// EA4: using guessed type int __fastcall eglChooseConfig(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// EC8: using guessed type int __fastcall eglInitialize(_DWORD, _DWORD, _DWORD);
// EFC: using guessed type int eglGetDisplay(void);
// F14: using guessed type int __fastcall dint_create_window(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// F38: using guessed type int __fastcall eglMakeCurrent(_DWORD, _DWORD, _DWORD, _DWORD);
// F44: using guessed type int __fastcall dint_get_native_window(_DWORD, _DWORD);
// F50: using guessed type int dint_init(void);
// 3024: using guessed type EGL_DEFINES dword_3024;
// 3088: using guessed type int eglDisplay;
// 308C: using guessed type int window;
// 3090: using guessed type int eglSurface;
// 3094: using guessed type int eglContext;
// 3098: using guessed type int glProgram;

//----- (000016D8) --------------------------------------------------------
int closeWindow()
{
  int v0; // r0

  if ( eglContext )
  {
    eglMakeCurrent(eglDisplay, 0, 0, 0);
    if ( eglContext )
    {
      eglDestroyContext(eglDisplay);
      eglContext = 0;
    }
  }
  if ( eglSurface )
  {
    eglDestroySurface(eglDisplay);
    eglSurface = 0;
  }
  dint_destroy_window(window);
  v0 = eglDisplay;
  if ( eglDisplay )
  {
    v0 = eglTerminate();
    eglDisplay = 0;
  }
  return deinit_dint(v0);
}
// D38: using guessed type int __fastcall eglDestroySurface(_DWORD);
// E50: using guessed type int eglTerminate(void);
// E68: using guessed type int __fastcall eglDestroyContext(_DWORD);
// EBC: using guessed type int __fastcall dint_destroy_window(_DWORD);
// F38: using guessed type int __fastcall eglMakeCurrent(_DWORD, _DWORD, _DWORD, _DWORD);
// 3088: using guessed type int eglDisplay;
// 308C: using guessed type int window;
// 3090: using guessed type int eglSurface;
// 3094: using guessed type int eglContext;

//----- (00001750) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=125 queued=14 decompiled=14 lumina nreq=0 worse=0 better=0
// ALL OK, 14 function(s) have been successfully decompiled
