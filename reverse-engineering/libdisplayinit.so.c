/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void init_proc();
// int sscanf(const char *s, const char *format, ...);
// int access(const char *name, int type);
// int __fastcall screen_get_display_property_iv(_DWORD, _DWORD, _DWORD); weak
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// __pid_t getpid(void);
// int strcmp(const char *s1, const char *s2);
// int __fastcall screen_set_window_property_iv(screen_window_t win, int pname, const int *param);
// int __fastcall screen_create_window_type(screen_window_t *pwin, screen_context_t ctx, int type);
// void *malloc(size_t size);
void j_dint_release_display_info(void *ptr); // idb
// int __fastcall screen_get_context_property_iv(_DWORD, _DWORD, _DWORD); weak
// int fflush(FILE *stream);
// int __fastcall screen_manage_window(screen_window_t window, char *str);
// char *strdup(const char *s);
// int __fastcall screen_destroy_window(screen_window_t win);
// int __fastcall screen_get_context_property_pv(_DWORD, _DWORD, _DWORD); weak
_DWORD *__fastcall j_esojson_parser_create(int, int, int, size_t, int);
// int __fastcall _register_frame_info(_DWORD, _DWORD); weak
// int fprintf(FILE *stream, const char *format, ...);
// int _get_errno_ptr(void); weak
size_t j_fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int __fastcall screen_get_display_property_cv(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void *calloc(size_t nmemb, size_t size);
// int __fastcall screen_set_window_property_cv(screen_window_t win, int pname, int len, const char *param);
void __fastcall j_esojson_parser_destroy(void **);
int __fastcall j_esojson_parser_parse(int);
// int __fastcall screen_create_window_buffers(screen_window_t win, int count);
void j_free(void *ptr);
// void free(void *ptr);
// int screen_destroy_context(void); weak
// int __fastcall screen_flush_context(int, int);
// int __fastcall screen_create_context(screen_context_t *pctx, int flags);
unsigned int __fastcall j_dint_get_display_info(unsigned int a1, void **a2);
// char *strerror(int errnum);
// int sprintf(char *s, const char *format, ...);
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall screen_get_window_property_iv(_DWORD, _DWORD, _DWORD); weak
// size_t strlen(const char *s);
void __fastcall sub_F1C(int, int, int, _DWORD *, int);
_DWORD *sub_11A8();
void __fastcall sub_11C0(void *ptr);
int __fastcall sub_11F0(int, char *s1); // idb
int __fastcall sub_1210(int);
int *__fastcall set_window_properties(unk_screen_window *win, int *properties);
int __fastcall dint_init();
unsigned int __fastcall dint_get_display_info(unsigned int a1, void **a2);
void dint_release_display_info(void *ptr);
int __fastcall dint_get_resolution(int result, _DWORD *, _DWORD *);
int __fastcall dint_create_window(int isOverlayWithVideo, int display_id, int width, int height, int *properties, unk_screen_window **window);
int *__fastcall dint_set_window_properties(screen_window_t *win, int *properties);
int __fastcall dint_get_native_window(unk_screen_window *window, screen_window_t *native_window_arg);
int __fastcall dint_destroy_window(_DWORD *);
screen_context_t dint_deinit();
int __fastcall sub_21C4(int);
int __fastcall sub_21EC(_DWORD *);
int __fastcall sub_22B8(_DWORD *, _BYTE *);
int __fastcall sub_22D8(int *, int);
void *__fastcall sub_231C(int, int);
int __fastcall sub_2360(int, const char *);
int __fastcall sub_23C0(char **);
int __fastcall sub_24B0(char **);
int __fastcall sub_2660(char **a1);
int __fastcall sub_2850(_DWORD *);
_DWORD *__fastcall esojson_parser_create(int, int, int, size_t, int);
void __fastcall esojson_parser_destroy(void **);
int __fastcall esojson_parser_parse(int);
void term_proc();
// int __fastcall screen_create_window_type(_DWORD, _DWORD, _DWORD); weak
// int __fastcall screen_manage_window(_DWORD, _DWORD); weak
// int __fastcall screen_create_window_buffers(_DWORD, _DWORD); weak
// char *strerror(int errnum);
// int Jv_RegisterClasses(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_4 = '\x01'; // weak
char byte_6 = '\x01'; // weak
char byte_7 = '\0'; // weak
char byte_8 = '\0'; // weak
char byte_9[7] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_UNKNOWN loc_F6C; // weak
_UNKNOWN loc_1164; // weak
_UNKNOWN _exidx_start; // weak
int dword_4EDC = 0; // weak
_UNKNOWN unk_50BC; // weak
screen_context_t g_context;
int dword_50D8; // weak
int dword_50DC; // weak
// extern FILE *Stderr;
// extern _UNKNOWN _stack_chk_guard; weak
// extern _UNKNOWN __register_frame_info; weak


//----- (00000C24) --------------------------------------------------------
void init_proc()
{
  ;
}

//----- (00000CB8) --------------------------------------------------------
// attributes: thunk
void __fastcall j_dint_release_display_info(void *ptr)
{
  dint_release_display_info(ptr);
}

//----- (00000D0C) --------------------------------------------------------
// attributes: thunk
_DWORD *__fastcall j_esojson_parser_create(int a1, int a2, int a3, size_t a4, int a5)
{
  return esojson_parser_create(a1, a2, a3, a4, a5);
}

//----- (00000D54) --------------------------------------------------------
// attributes: thunk
size_t j_fread(void *ptr, size_t size, size_t n, FILE *stream)
{
  return fread(ptr, size, n, stream);
}

//----- (00000D88) --------------------------------------------------------
// attributes: thunk
void __fastcall j_esojson_parser_destroy(void **a1)
{
  esojson_parser_destroy(a1);
}

//----- (00000D94) --------------------------------------------------------
// attributes: thunk
int __fastcall j_esojson_parser_parse(int a1)
{
  return esojson_parser_parse(a1);
}

//----- (00000DAC) --------------------------------------------------------
// attributes: thunk
void j_free(void *ptr)
{
  free(ptr);
}

//----- (00000DE0) --------------------------------------------------------
// attributes: thunk
unsigned int __fastcall j_dint_get_display_info(unsigned int a1, void **a2)
{
  return dint_get_display_info(a1, a2);
}

//----- (00000F1C) --------------------------------------------------------
void __fastcall sub_F1C(int a1, int a2, int a3, _DWORD *a4, int a5)
{
  unsigned int v6; // r11
  int v7; // t0
  int v11; // r6
  int v12; // r8
  int v13; // r9
  int v14; // r11
  unsigned int *v15; // r12
  int v16; // r0
  _DWORD *v17; // r3
  int v18; // r4
  int v19; // lr
  int savedregsa; // [sp+0h] [bp+0h]
  _DWORD *savedregs_4a; // [sp+4h] [bp+4h]
  int savedregs_4; // [sp+4h] [bp+4h]
  int savedregs_8; // [sp+8h] [bp+8h]
  int savedregs_12a; // [sp+Ch] [bp+Ch]
  int savedregs_12; // [sp+Ch] [bp+Ch]

  if ( &__register_frame_info )
    _register_frame_info(&_exidx_start, &unk_50BC);
  v16 = (int)&dword_4EDC;
  if ( dword_4EDC )
  {
    _VF = 0;
    _ZF = &Jv_RegisterClasses == 0;
    _NF = (int)&Jv_RegisterClasses < 0;
    if ( &Jv_RegisterClasses )
      v16 = Jv_RegisterClasses();
  }
  v17 = a4;
  v18 = savedregs_4;
  v19 = savedregs_12;
  if ( _NF )
  {
    savedregsa = a3;
    savedregs_4a = v17;
    savedregs_8 = v12;
    savedregs_12a = v14;
    a5 = v14;
    v16 = MEMORY[0x352070]();
  }
  if ( !_ZF )
    JUMPOUT(0x252070);
  if ( _NF != _VF )
  {
    *(_DWORD *)v16 = v18;
    v16 += 1147;
  }
  else
  {
    __asm { SVCGE           0x1089 }
  }
  if ( !_VF )
  {
    v19 = a2 & ~(a2 << 22);
    _ZF = v19 == 0;
    _NF = v19 < 0;
  }
  if ( _NF ^ _VF | _ZF )
    a2 = v11 & (v13 >> 31);
  if ( _NF )
  {
    v6 = __ssat(4 * v14, 4 * v14);
  }
  else
  {
    v17 = *(_DWORD **)v14;
    v13 = *(_DWORD *)(v14 + 4);
    v7 = v14 + 8;
    v6 = *(_DWORD *)(v14 + 8);
    v19 = *(_DWORD *)(v7 + 4);
  }
  if ( !_VF )
    v16 = MEMORY[0x13F020](v16, a2, a3, v17);
  if ( _NF )
    v18 = __ssat(v12 << 14, v12 << 14);
  if ( !_VF )
    v16 = MEMORY[0x13F028](v16, a2, a3, v17);
  if ( _NF != _VF )
    __asm { SVCLT           0x4770 }
  if ( _ZF )
  {
    v18 = v16 & (v16 >> a2);
    v16 &= (_DWORD)v15 << v16;
  }
  if ( _NF == _VF )
    __asm { SVCGE           0xB598 }
  if ( _NF )
  {
    __asm { STCMI           p11, c4, [LR], {0xD} }
    v15 = (unsigned int *)((char *)v15 - 1147);
    v18 = __ldrt(v15);
  }
  if ( _NF != _VF )
  {
    v17[1] = v16;
    v17[2] = a2;
    v17[3] = v17;
    v17[4] = v18;
    v17[5] = v6;
    v17[6] = v15;
    v17[7] = &a5;
    v17[8] = v19;
    v17 += 8;
  }
  if ( _NF )
  {
    MEMORY[0x32D36C](v16, a2, a3, v17);
  }
  else
  {
    *v17 = a3;
    v17[1] = v17;
    v17[2] = v12;
    v17[3] = v13;
    v17[4] = v6;
    v17[5] = v19;
  }
  __asm { SVC             0x20F7FF }
  JUMPOUT(0xEE4);
}
// EE0: control flows out of bounds to EE4
// E88: control flows out of bounds to 252070
// F40: variable 'savedregs_4' is possibly undefined
// F40: variable 'savedregs_12' is possibly undefined
// E80: variable '_NF' is possibly undefined
// E80: variable 'a3' is possibly undefined
// E80: variable 'v12' is possibly undefined
// E80: variable 'v14' is possibly undefined
// E88: variable '_ZF' is possibly undefined
// E8C: variable '_VF' is possibly undefined
// E94: variable 'a2' is possibly undefined
// E98: variable 'v11' is possibly undefined
// E98: variable 'v13' is possibly undefined
// EA4: variable 'v17' is possibly undefined
// EC0: variable 'v15' is possibly undefined
// D30: using guessed type int __fastcall _register_frame_info(_DWORD, _DWORD);
// 4EDC: using guessed type int dword_4EDC;
// 517C: using guessed type int Jv_RegisterClasses(void);

//----- (000011A8) --------------------------------------------------------
_DWORD *sub_11A8()
{
  _DWORD *result; // r0

  result = calloc(1u, 0x40u);
  result[6] = -1;
  result[7] = -1;
  result[8] = -1;
  return result;
}

//----- (000011C0) --------------------------------------------------------
void __fastcall sub_11C0(void *ptr)
{
  int v2; // r4
  int v3; // r5
  void *v4; // r0

  v2 = *((_DWORD *)ptr + 15);
  if ( v2 )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 16);
      free(*(void **)(v2 + 12));
      free((void *)v2);
      v2 = v3;
    }
    while ( v3 );
  }
  v4 = (void *)*((_DWORD *)ptr + 1);
  if ( v4 )
    free(v4);
  j_free(ptr);
}

//----- (000011F0) --------------------------------------------------------
int __fastcall sub_11F0(int a1, char *s1)
{
  int i; // r4

  for ( i = *(_DWORD *)(a1 + 56); i; i = *(_DWORD *)(i + 8) )
  {
    if ( !strcmp(s1, *(const char **)(i + 4)) )
      break;
  }
  return i;
}

//----- (00001210) --------------------------------------------------------
int __fastcall sub_1210(int a1)
{
  void **v2; // r9
  int i; // r4
  char *v4; // r5
  const char **v5; // r6
  int v6; // r4
  int v7; // r5

  v2 = (void **)j_esojson_parser_create((int)&loc_F6C + 1, (int)&loc_1164 + 1, 1024, 0x400u, a1);
  if ( !j_esojson_parser_parse((int)v2) )
  {
    for ( i = *(_DWORD *)(a1 + 60); i; i = *(_DWORD *)(i + 16) )
    {
      v4 = *(char **)(i + 12);
      v5 = (const char **)sub_11F0(a1, v4);
      free(v4);
      *(_DWORD *)(i + 12) = 0;
      if ( v5 )
        *(_DWORD *)(i + 12) = strdup(*v5);
    }
    v6 = *(_DWORD *)(a1 + 56);
    if ( v6 )
    {
      do
      {
        v7 = *(_DWORD *)(v6 + 8);
        free(*(void **)(v6 + 4));
        free(*(void **)v6);
        free((void *)v6);
        v6 = v7;
      }
      while ( v7 );
      *(_DWORD *)(a1 + 56) = 0;
    }
  }
  j_esojson_parser_destroy(v2);
  return *(_DWORD *)(a1 + 60);
}

//----- (00001298) --------------------------------------------------------
int *__fastcall set_window_properties(unk_screen_window *win, int *properties)
{
  int v2; // r5
  int *v4; // r9
  int v5; // r3
  int v6; // r4
  int *v7; // r10
  int v8; // r4
  struct _screen_window *native_window; // r0
  int v10; // r5
  __pid_t v11; // r6
  char *v12; // r0
  int v14; // r10
  __pid_t v15; // r11
  char *v16; // r0
  __pid_t v17; // r2
  const char *v18; // r3
  struct _screen_window *v19; // r0
  int v20; // r10
  __pid_t v21; // r11
  char *v22; // r0
  __pid_t v23; // r2
  const char *v24; // r3
  struct _screen_window *v25; // r0
  __pid_t v26; // r11
  struct _screen_window *v27; // r0
  __pid_t v28; // r11
  int v29; // r5
  int v30; // r3
  __pid_t v31; // r11
  int v32; // r5
  int v33; // r3
  __pid_t v34; // r11
  int v35; // r5
  int v36; // r3
  __pid_t v37; // r11
  __pid_t v38; // r0
  int v39; // r3
  const char *v40; // r1
  __pid_t v41; // r2
  __pid_t v42; // r0
  __pid_t v43; // r0
  int v44; // r5
  __pid_t v45; // r6
  char *v46; // r0
  int v47; // r7
  __pid_t v48; // r10
  char *v49; // r0
  int v50; // r10
  __pid_t v51; // r11
  char *v52; // r0
  int v53; // r10
  __pid_t v54; // r11
  char *v55; // r0
  __pid_t v56; // r11
  int v57; // r6
  __pid_t v58; // r10
  char *v59; // r0
  int v61; // [sp+2Ch] [bp-3Ch] BYREF
  int param; // [sp+30h] [bp-38h] BYREF
  int v63; // [sp+34h] [bp-34h] BYREF
  int v64; // [sp+38h] [bp-30h]

  v2 = 0;
  v4 = properties;
  win->nBuffers = 2;
  v61 = 0;
  param = 0;
  if ( properties )
  {
    v5 = *properties;
    v4 = (int *)*properties;
    if ( *properties )
    {
      v6 = 0;
      v4 = 0;
      v7 = properties;
      while ( 2 )
      {
        switch ( v5 )
        {
          case 1:
            param = properties[v2 + 1];
            goto LABEL_7;
          case 2:
            v35 = v2 + 1;
            v36 = properties[v35];
            if ( v36 )
            {
              if ( v36 == 1 )
              {
                if ( screen_set_window_property_cv(win->native_window, 7, 7, "capture") )
                  goto LABEL_47;
              }
              else
              {
                v42 = getpid();
                v4 = &dword_0 + 3;
                v39 = properties[v35];
                v40 = "[libdisplayinit.so][pid: %d] unknown value (%d) for property DINT_PROPERTY_OVERLAY_TYPE\n";
                v41 = v42;
LABEL_50:
                fprintf((FILE *)&Stderr, v40, v41, v39);
                fflush((FILE *)&Stderr);
              }
            }
            else if ( screen_set_window_property_cv(win->native_window, SCREEN_PROPERTY_CLASS, 5, "media") )
            {
LABEL_47:
              v20 = *(_DWORD *)_get_errno_ptr();
              v37 = getpid();
              v22 = strerror(v20);
              v23 = v37;
              v24 = "screen_set_window_property_cv(window->native_window, SCREEN_PROPERTY_CLASS, strlen(clz), clz)";
              goto LABEL_39;
            }
LABEL_7:
            v6 += 2;
            v5 = properties[v6];
            v2 = v6;
            v7 = &properties[v6];
            if ( v5 )
              continue;
            if ( param )
            {
              if ( screen_set_window_property_iv(win->native_window, SCREEN_PROPERTY_ROTATION, &param) )
              {
                v44 = *(_DWORD *)_get_errno_ptr();
                v45 = getpid();
                v46 = strerror(v44);
                fprintf(
                  (FILE *)&Stderr,
                  "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
                  v45,
                  "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_ROTATION, &rotation)",
                  v44,
                  v46);
                fflush((FILE *)&Stderr);
              }
              if ( ((param / 90) & 1) != 0 )
              {
                if ( screen_get_window_property_iv(win->native_window, SCREEN_PROPERTY_SIZE, &v63) )
                {
                  v57 = *(_DWORD *)_get_errno_ptr();
                  v58 = getpid();
                  v59 = strerror(v57);
                  fprintf(
                    (FILE *)&Stderr,
                    "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
                    v58,
                    "screen_get_window_property_iv(window->native_window, SCREEN_PROPERTY_SIZE, size)",
                    v57,
                    v59);
                  fflush((FILE *)&Stderr);
                }
                v8 = v64;
                native_window = win->native_window;
                v64 = v63;
                v63 = v8;
                if ( screen_set_window_property_iv(native_window, SCREEN_PROPERTY_SIZE, &v63) )
                {
                  v10 = *(_DWORD *)_get_errno_ptr();
                  v11 = getpid();
                  v12 = strerror(v10);
                  fprintf(
                    (FILE *)&Stderr,
                    "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
                    v11,
                    "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_SIZE, size)",
                    v10,
                    v12);
                  fflush((FILE *)&Stderr);
                }
              }
            }
            break;
          case 3:
            v32 = v2 + 1;
            v33 = properties[v32];
            if ( v33 )
            {
              if ( v33 != 1 )
              {
                v43 = getpid();
                v4 = &dword_0 + 3;
                v39 = properties[v32];
                v40 = "[libdisplayinit.so][pid: %d] unknown value (%d) for property DINT_PROPERTY_PIXEL_FORMAT\n";
                v41 = v43;
                goto LABEL_50;
              }
              v61 = 13;
              if ( !screen_set_window_property_iv(win->native_window, SCREEN_PROPERTY_FORMAT, &v61) )
                goto LABEL_7;
            }
            else
            {
              v61 = 8;
              if ( !screen_set_window_property_iv(win->native_window, SCREEN_PROPERTY_FORMAT, &v61) )
                goto LABEL_7;
            }
            v20 = *(_DWORD *)_get_errno_ptr();
            v34 = getpid();
            v22 = strerror(v20);
            v23 = v34;
            v24 = "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_FORMAT, &iVal)";
LABEL_39:
            fprintf((FILE *)&Stderr, "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n", v23, v24, v20, v22);
            fflush((FILE *)&Stderr);
            goto LABEL_7;
          case 4:
            if ( screen_get_window_property_iv(win->native_window, SCREEN_PROPERTY_USAGE, &v61) )
            {
              v47 = *(_DWORD *)_get_errno_ptr();
              v48 = getpid();
              v49 = strerror(v47);
              fprintf(
                (FILE *)&Stderr,
                "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
                v48,
                "screen_get_window_property_iv(window->native_window, SCREEN_PROPERTY_USAGE, &iVal)",
                v47,
                v49);
              fflush((FILE *)&Stderr);
            }
            if ( properties[v2 + 1] > 0 )
              v30 = v61 | 0x20;
            else
              v30 = v61 & 0xFFFFFFDF;
            v61 = v30;
            if ( !screen_set_window_property_iv(win->native_window, SCREEN_PROPERTY_USAGE, &v61) )
              goto LABEL_7;
            v20 = *(_DWORD *)_get_errno_ptr();
            v31 = getpid();
            v22 = strerror(v20);
            v23 = v31;
            v24 = "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_USAGE, &iVal)";
            goto LABEL_39;
          case 5:
            win->nBuffers = properties[v2 + 1];
            goto LABEL_7;
          case 6:
            v29 = v2 + 1;
            if ( screen_set_window_property_iv(win->native_window, SCREEN_PROPERTY_SOURCE_POSITION, &properties[v29]) )
            {
              v53 = *(_DWORD *)_get_errno_ptr();
              v54 = getpid();
              v55 = strerror(v53);
              fprintf(
                (FILE *)&Stderr,
                "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
                v54,
                "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_SOURCE_POSITION, &prop_list[i + 1])",
                v53,
                v55);
              fflush((FILE *)&Stderr);
            }
            if ( screen_set_window_property_iv(win->native_window, SCREEN_PROPERTY_SOURCE_SIZE, &properties[v29 + 2]) )
            {
              v50 = *(_DWORD *)_get_errno_ptr();
              v51 = getpid();
              v52 = strerror(v50);
              fprintf(
                (FILE *)&Stderr,
                "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
                v51,
                "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_SOURCE_SIZE, &prop_list[i + 3])",
                v50,
                v52);
              fflush((FILE *)&Stderr);
            }
            v6 += 3;
            goto LABEL_7;
          case 7:
            v25 = win->native_window;
            v61 = properties[v2 + 1];
            if ( !screen_set_window_property_iv(v25, SCREEN_PROPERTY_PIPELINE, &v61) )
              goto LABEL_7;
            v20 = *(_DWORD *)_get_errno_ptr();
            v26 = getpid();
            v22 = strerror(v20);
            v23 = v26;
            v24 = "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_PIPELINE, &iVal)";
            goto LABEL_39;
          case 8:
            v19 = win->native_window;
            v61 = properties[v2 + 1];
            if ( !screen_set_window_property_iv(v19, SCREEN_PROPERTY_ZORDER, &v61) )
              goto LABEL_7;
            v20 = *(_DWORD *)_get_errno_ptr();
            v21 = getpid();
            v22 = strerror(v20);
            v23 = v21;
            v24 = "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_ZORDER, &iVal)";
            goto LABEL_39;
          case 9:
            v27 = win->native_window;
            v61 = properties[v2 + 1];
            if ( !screen_set_window_property_iv(v27, SCREEN_PROPERTY_VISIBLE, &v61) )
              goto LABEL_7;
            v20 = *(_DWORD *)_get_errno_ptr();
            v28 = getpid();
            v22 = strerror(v20);
            v23 = v28;
            v24 = "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_VISIBLE, &iVal)";
            goto LABEL_39;
          case 10:
            if ( !screen_set_window_property_iv(win->native_window, SCREEN_PROPERTY_POSITION, &properties[v2 + 1]) )
              goto LABEL_6;
            v14 = *(_DWORD *)_get_errno_ptr();
            v15 = getpid();
            v16 = strerror(v14);
            v17 = v15;
            v18 = "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_POSITION, &prop_list[i + 1])";
            goto LABEL_19;
          case 11:
            if ( !screen_set_window_property_iv(win->native_window, SCREEN_PROPERTY_SIZE, &properties[v2 + 1]) )
              goto LABEL_6;
            v14 = *(_DWORD *)_get_errno_ptr();
            v56 = getpid();
            v16 = strerror(v14);
            v17 = v56;
            v18 = "screen_set_window_property_iv(window->native_window, SCREEN_PROPERTY_SIZE, &prop_list[i + 1])";
LABEL_19:
            fprintf((FILE *)&Stderr, "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n", v17, v18, v14, v16);
            fflush((FILE *)&Stderr);
LABEL_6:
            ++v6;
            goto LABEL_7;
          default:
            v38 = getpid();
            v39 = *v7;
            v4 = &dword_0 + 3;
            v40 = "[libdisplayinit.so][pid: %d] unknown property: %d\n";
            v41 = v38;
            goto LABEL_50;
        }
        break;
      }
    }
  }
  return v4;
}
// 0: using guessed type int dword_0;
// D48: using guessed type int _get_errno_ptr(void);
// E10: using guessed type int __fastcall screen_get_window_property_iv(_DWORD, _DWORD, _DWORD);

//----- (000018EC) --------------------------------------------------------
int __fastcall dint_init()
{
  int result; // r0
  __pid_t v1; // r0
  int v2; // r6
  __pid_t v3; // r7
  char *v4; // r0

  result = 4;
  if ( !g_context )
  {
    if ( access("/dev/screen", (int)g_context) )
    {
      v1 = getpid();
      fprintf((FILE *)&Stderr, "[libdisplayinit.so][pid: %d] dint_init() failed to access /dev/screen -> retry\n", v1);
      fflush((FILE *)&Stderr);
    }
    else
    {
      result = screen_create_context(&g_context, SCREEN_APPLICATION_CONTEXT);
      if ( !result )
        return result;
      v2 = *(_DWORD *)_get_errno_ptr();
      v3 = getpid();
      v4 = strerror(v2);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v3,
        "screen_create_context(&g_context, SCREEN_APPLICATION_CONTEXT)",
        v2,
        v4);
      fflush((FILE *)&Stderr);
    }
    result = 2;
    g_context = 0;
  }
  return result;
}
// D48: using guessed type int _get_errno_ptr(void);

//----- (00001990) --------------------------------------------------------
unsigned int __fastcall dint_get_display_info(unsigned int a1, void **a2)
{
  unsigned int result; // r0
  int v5; // r5
  _DWORD *v6; // r0
  unsigned int v7; // r1
  unsigned int v8; // r2
  char *v9; // r7
  signed int v10; // r6
  int v11; // t1
  int v12; // r10
  __pid_t v13; // r9
  char *v14; // r0
  _DWORD *v15; // r3
  int v16; // r7
  __pid_t v17; // r8
  char *v18; // r0
  int v19; // r7
  __pid_t v20; // r8
  char *v21; // r0
  int v22; // r7
  __pid_t v23; // r8
  char *v24; // r0
  void *v25; // [sp+8h] [bp-70h]
  int v26; // [sp+Ch] [bp-6Ch]
  char *ptr; // [sp+18h] [bp-60h]
  void **v28; // [sp+1Ch] [bp-5Ch]
  size_t nmemb; // [sp+20h] [bp-58h] BYREF
  int v30[2]; // [sp+24h] [bp-54h] BYREF
  char v31[32]; // [sp+2Ch] [bp-4Ch] BYREF

  v25 = &_stack_chk_guard;
  if ( !g_context )
    return 1;
  if ( a1 > 6 )
    return 3;
  if ( dword_50DC )
  {
    v5 = dword_50D8;
    if ( dword_50D8 )
      goto LABEL_10;
    return 5;
  }
  dword_50DC = (int)sub_11A8();
  v5 = sub_1210(dword_50DC);
  dword_50D8 = v5;
  if ( !v5 )
    return 5;
LABEL_10:
  while ( a1 != *(_DWORD *)v5 )
  {
    v5 = *(_DWORD *)(v5 + 16);
    if ( !v5 )
      return 5;
  }
  v6 = calloc(1u, 0xCu);
  v7 = *(_DWORD *)(v5 + 8);
  v8 = *(_DWORD *)(v5 + 4);
  *a2 = v6;
  *v6 = a1;
  v6[1] = v8;
  v6[2] = v7;
  result = (v7 >> 31) | (v8 >> 31);
  if ( result )
  {
    nmemb = 0;
    if ( screen_get_context_property_iv(g_context, SCREEN_PROPERTY_DISPLAY_COUNT, &nmemb) )
    {
      v19 = *(_DWORD *)_get_errno_ptr();
      v20 = getpid();
      v21 = strerror(v19);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v20,
        "screen_get_context_property_iv(g_context, SCREEN_PROPERTY_DISPLAY_COUNT, &nDisplays)",
        v19,
        v21);
      fflush((FILE *)&Stderr);
    }
    ptr = (char *)calloc(nmemb, 4u);
    if ( screen_get_context_property_pv(g_context, SCREEN_PROPERTY_DISPLAYS, ptr) )
    {
      v16 = *(_DWORD *)_get_errno_ptr();
      v17 = getpid();
      v18 = strerror(v16);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v17,
        "screen_get_context_property_pv(g_context, SCREEN_PROPERTY_DISPLAYS, (void** ) displays)",
        v16,
        v18);
      fflush((FILE *)&Stderr);
    }
    if ( (int)nmemb <= 0 )
    {
      free(ptr);
    }
    else
    {
      v9 = ptr - 4;
      v26 = 0;
      v10 = 0;
      v28 = a2;
      do
      {
        v11 = *((_DWORD *)v9 + 1);
        v9 += 4;
        if ( screen_get_display_property_cv(v11, SCREEN_PROPERTY_ID_STRING, 32, v31) )
        {
          v12 = *(_DWORD *)_get_errno_ptr();
          v13 = getpid();
          v14 = strerror(v12);
          fprintf(
            (FILE *)&Stderr,
            "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
            v13,
            "screen_get_display_property_cv(displays[i], SCREEN_PROPERTY_ID_STRING, sizeof(name), name)",
            v12,
            v14,
            v25);
          fflush((FILE *)&Stderr);
        }
        if ( !strcmp(v31, *(const char **)(v5 + 12)) )
          v26 = *(_DWORD *)v9;
        ++v10;
      }
      while ( v10 < (int)nmemb );
      a2 = v28;
      free(ptr);
      if ( v26 )
      {
        if ( screen_get_display_property_iv(v26, SCREEN_PROPERTY_SIZE, v30) )
        {
          v22 = *(_DWORD *)_get_errno_ptr();
          v23 = getpid();
          v24 = strerror(v22);
          fprintf(
            (FILE *)&Stderr,
            "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
            v23,
            "screen_get_display_property_iv(screen_display, SCREEN_PROPERTY_SIZE, size)",
            v22,
            v24);
          fflush((FILE *)&Stderr);
        }
        v15 = *v28;
        result = 0;
        if ( *((int *)*v28 + 1) < 0 )
          v15[1] = v30[0];
        if ( (int)v15[2] < 0 )
          v15[2] = v30[1];
        return result;
      }
    }
    free(*a2);
    return 5;
  }
  return result;
}
// 26: found interdependent unknown calls
// 1ABC: variable 'v25' is possibly undefined
// C58: using guessed type int __fastcall screen_get_display_property_iv(_DWORD, _DWORD, _DWORD);
// CC4: using guessed type int __fastcall screen_get_context_property_iv(_DWORD, _DWORD, _DWORD);
// D00: using guessed type int __fastcall screen_get_context_property_pv(_DWORD, _DWORD, _DWORD);
// D48: using guessed type int _get_errno_ptr(void);
// D64: using guessed type int __fastcall screen_get_display_property_cv(_DWORD, _DWORD, _DWORD, _DWORD);
// 50D8: using guessed type int dword_50D8;
// 50DC: using guessed type int dword_50DC;

//----- (00001C18) --------------------------------------------------------
int __fastcall dint_get_resolution(int result, _DWORD *a2, _DWORD *a3)
{
  bool v3; // zf
  _DWORD *v5; // r0
  void *ptr; // [sp+8h] [bp-18h] BYREF

  v3 = a3 == 0;
  if ( a3 )
    v3 = a2 == 0;
  if ( v3 )
    result = 3;
  if ( !v3 )
  {
    ptr = 0;
    result = j_dint_get_display_info(result, &ptr);
    if ( !result )
    {
      v5 = ptr;
      *a2 = *((_DWORD *)ptr + 1);
      *a3 = v5[2];
      j_dint_release_display_info(v5);
      return 0;
    }
  }
  return result;
}

//----- (00001C7C) --------------------------------------------------------
int __fastcall dint_create_window(
        int isOverlayWithVideo,
        int display_id,
        int width,
        int height,
        int *properties,
        unk_screen_window **window)
{
  int result; // r0
  unk_screen_window *pwin; // r0
  unk_screen_window *win; // r3
  unk_screen_window *win_1; // r3
  unk_screen_window *win_2; // r3
  int v14; // r0
  unk_screen_window *win_3; // r3
  $C9EC76578024B99B23CBFCBC866CE6E2 flags_1; // r0
  int *v17; // r6
  __pid_t pid; // r0
  int v19; // r3
  int v20; // r8
  __pid_t v21; // r11
  char *v22; // r0
  int v23; // r8
  __pid_t v24; // r11
  char *v25; // r0
  int v26; // r8
  char *v27; // r0
  int v28; // r11
  char *v29; // r0
  int error_id; // r11
  __pid_t pid_1; // r10
  char *error_reason; // r0
  int v33; // r7
  __pid_t v34; // r8
  char *v35; // r0
  int v36; // r8
  __pid_t v37; // r9
  char *v38; // r0
  int v39; // r7
  __pid_t v40; // r8
  char *v41; // r0
  __pid_t v43; // [sp+Ch] [bp-54h]
  __pid_t v44; // [sp+14h] [bp-4Ch]
  unsigned int flags; // [sp+18h] [bp-48h] BYREF
  int param[2]; // [sp+1Ch] [bp-44h] BYREF
  char s[16]; // [sp+24h] [bp-3Ch] BYREF

  result = 1;
  if ( g_context )
  {
    pwin = (unk_screen_window *)calloc(1u, 8u);
    *window = pwin;
    if ( screen_create_window_type(&pwin->native_window, g_context, SCREEN_APPLICATION_WINDOW) )
    {
      error_id = *(_DWORD *)_get_errno_ptr();
      pid_1 = getpid();
      error_reason = strerror(error_id);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        pid_1,
        "screen_create_window_type(&(*window)->native_window, g_context, SCREEN_APPLICATION_WINDOW)",
        error_id,
        error_reason);
      fflush((FILE *)&Stderr);
    }
    win = *window;
    flags = 1;
    if ( screen_set_window_property_iv(win->native_window, SCREEN_PROPERTY_VISIBLE, (const int *)&flags) )
    {
      v28 = *(_DWORD *)_get_errno_ptr();
      v44 = getpid();
      v29 = strerror(v28);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v44,
        "screen_set_window_property_iv((*window)->native_window, SCREEN_PROPERTY_VISIBLE, &iVal)",
        v28,
        v29);
      fflush((FILE *)&Stderr);
    }
    win_1 = *window;
    param[0] = width;
    param[1] = height;
    if ( screen_set_window_property_iv(win_1->native_window, SCREEN_PROPERTY_SIZE, param) )
    {
      v26 = *(_DWORD *)_get_errno_ptr();
      v43 = getpid();
      v27 = strerror(v26);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v43,
        "screen_set_window_property_iv((*window)->native_window, SCREEN_PROPERTY_SIZE, size)",
        v26,
        v27);
      fflush((FILE *)&Stderr);
    }
    if ( screen_set_window_property_iv((*window)->native_window, SCREEN_PROPERTY_BUFFER_SIZE, param) )
    {
      v23 = *(_DWORD *)_get_errno_ptr();
      v24 = getpid();
      v25 = strerror(v23);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v24,
        "screen_set_window_property_iv((*window)->native_window, SCREEN_PROPERTY_BUFFER_SIZE, size)",
        v23,
        v25);
      fflush((FILE *)&Stderr);
    }
    win_2 = *window;
    flags = SCREEN_FORMAT_RGBA8888;
    if ( screen_set_window_property_iv(win_2->native_window, SCREEN_PROPERTY_FORMAT, (const int *)&flags) )
    {
      v20 = *(_DWORD *)_get_errno_ptr();
      v21 = getpid();
      v22 = strerror(v20);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v21,
        "screen_set_window_property_iv((*window)->native_window, SCREEN_PROPERTY_FORMAT, &iVal)",
        v20,
        v22);
      fflush((FILE *)&Stderr);
    }
    flags = snprintf(s, 16u, "%d", display_id);
    if ( flags > 15 )
    {
      pid = getpid();
      v19 = display_id;
      v17 = &dword_0 + 3;
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] displayable id (%i) exceeds maximum number of characters\n",
        pid,
        v19);
      fflush((FILE *)&Stderr);
LABEL_21:
      screen_destroy_window((*window)->native_window);
      (*window)->native_window = 0;
      free(*window);
      result = (int)v17;
      *window = 0;
      return result;
    }
    v14 = strlen(s);
    if ( screen_set_window_property_cv((*window)->native_window, SCREEN_PROPERTY_ID_STRING, v14, s) )
    {
      v33 = *(_DWORD *)_get_errno_ptr();
      v34 = getpid();
      v35 = strerror(v33);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v34,
        "screen_set_window_property_cv((*window)->native_window, SCREEN_PROPERTY_ID_STRING, strlen(cBuf), cBuf)",
        v33,
        v35);
      fflush((FILE *)&Stderr);
    }
    win_3 = *window;
    if ( isOverlayWithVideo )
      flags_1 = SCREEN_USAGE_OVERLAY|SCREEN_USAGE_VIDEO;
    else
      flags_1 = SCREEN_USAGE_OPENGL_ES2;
    flags = flags_1;
    if ( screen_set_window_property_iv(win_3->native_window, SCREEN_PROPERTY_USAGE, (const int *)&flags) )
    {
      v39 = *(_DWORD *)_get_errno_ptr();
      v40 = getpid();
      v41 = strerror(v39);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v40,
        "screen_set_window_property_iv((*window)->native_window, SCREEN_PROPERTY_USAGE, &iVal)",
        v39,
        v41);
      fflush((FILE *)&Stderr);
    }
    v17 = set_window_properties(*window, properties);
    if ( v17 )
      goto LABEL_21;
    screen_manage_window((*window)->native_window, "How are you gentlemen?");
    result = screen_create_window_buffers((*window)->native_window, (*window)->nBuffers);
    if ( result )
    {
      v17 = (_DWORD *)&byte_6;
      v36 = *(_DWORD *)_get_errno_ptr();
      v37 = getpid();
      v38 = strerror(v36);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v37,
        "screen_create_window_buffers((*window)->native_window, (*window)->nBuffers)",
        v36,
        v38);
      fflush((FILE *)&Stderr);
      goto LABEL_21;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 6: using guessed type char byte_6;
// D48: using guessed type int _get_errno_ptr(void);

//----- (00002004) --------------------------------------------------------
int *__fastcall dint_set_window_properties(screen_window_t *win, int *properties)
{
  int *v2; // r4
  int v4; // r7
  __pid_t v5; // r8
  char *v6; // r0

  if ( !g_context )
    return &dword_0 + 1;
  v2 = set_window_properties((unk_screen_window *)win, properties);
  if ( screen_flush_context((int)g_context, 0) )
  {
    v4 = *(_DWORD *)_get_errno_ptr();
    v5 = getpid();
    v6 = strerror(v4);
    fprintf(
      (FILE *)&Stderr,
      "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
      v5,
      "screen_flush_context(g_context, 0)",
      v4,
      v6);
    fflush((FILE *)&Stderr);
  }
  return v2;
}
// 0: using guessed type int dword_0;
// D48: using guessed type int _get_errno_ptr(void);

//----- (00002084) --------------------------------------------------------
int __fastcall dint_get_native_window(unk_screen_window *window, screen_window_t *native_window_arg)
{
  struct _screen_window *native_window; // r3
  bool v3; // zf
  int result; // r0

  if ( !g_context )
    return 1;
  if ( !window )
    return 3;
  native_window = window->native_window;
  v3 = window->native_window == 0;
  if ( window->native_window )
    v3 = native_window_arg == 0;
  result = v3;
  if ( v3 )
    return 3;
  *native_window_arg = native_window;
  return result;
}

//----- (000020B0) --------------------------------------------------------
int __fastcall dint_destroy_window(_DWORD *a1)
{
  int v3; // r7
  __pid_t v4; // r8
  char *v5; // r0

  if ( !g_context )
    return 1;
  if ( !a1 || !*a1 )
    return 3;
  if ( screen_destroy_window((screen_window_t)*a1) )
  {
    v3 = *(_DWORD *)_get_errno_ptr();
    v4 = getpid();
    v5 = strerror(v3);
    fprintf(
      (FILE *)&Stderr,
      "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
      v4,
      "screen_destroy_window(window->native_window)",
      v3,
      v5);
    fflush((FILE *)&Stderr);
  }
  free(a1);
  return 0;
}
// D48: using guessed type int _get_errno_ptr(void);

//----- (00002138) --------------------------------------------------------
screen_context_t dint_deinit()
{
  screen_context_t result; // r0
  int v1; // r6
  __pid_t v2; // r7
  char *v3; // r0

  if ( dword_50DC )
  {
    sub_11C0((void *)dword_50DC);
    dword_50DC = 0;
    dword_50D8 = 0;
  }
  result = g_context;
  if ( g_context )
  {
    result = (screen_context_t)screen_destroy_context();
    if ( result )
    {
      v1 = *(_DWORD *)_get_errno_ptr();
      v2 = getpid();
      v3 = strerror(v1);
      fprintf(
        (FILE *)&Stderr,
        "[libdisplayinit.so][pid: %d] %s failed with error %i (%s)\n",
        v2,
        "screen_destroy_context(g_context)",
        v1,
        v3);
      result = (screen_context_t)fflush((FILE *)&Stderr);
    }
    g_context = 0;
  }
  return result;
}
// D48: using guessed type int _get_errno_ptr(void);
// DBC: using guessed type int screen_destroy_context(void);
// 50D8: using guessed type int dword_50D8;
// 50DC: using guessed type int dword_50DC;

//----- (000021C4) --------------------------------------------------------
int __fastcall sub_21C4(int a1)
{
  int result; // r0
  int v3; // r2
  bool v4; // cc

  result = (*(int (__fastcall **)(_DWORD, _DWORD, _DWORD))(a1 + 84))(
             *(_DWORD *)(a1 + 28),
             *(_DWORD *)(a1 + 32),
             *(_DWORD *)(a1 + 92));
  v4 = result <= 0;
  if ( result <= 0 )
  {
    result = -1;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = result;
    v3 = *(_DWORD *)(a1 + 28);
  }
  if ( v4 )
    *(_DWORD *)(a1 + 16) = 0;
  else
    *(_DWORD *)(a1 + 40) = 0;
  if ( !v4 )
    *(_BYTE *)(v3 + result) = 0;
  return result;
}
// 21E8: variable 'v3' is possibly undefined

//----- (000021EC) --------------------------------------------------------
int __fastcall sub_21EC(_DWORD *a1)
{
  int v2; // r2
  int v3; // r3
  int v4; // r8
  int v5; // r7
  char *v6; // r0
  char v7; // r3
  bool v8; // zf
  int v9; // r2
  int v11; // r4

  if ( a1[5] != 1 )
  {
    v2 = a1[10];
    v3 = a1[9];
    v4 = 0;
    v5 = 0;
    v6 = (char *)(a1[7] + v2);
    if ( v2 == v3 )
      goto LABEL_14;
    while ( 1 )
    {
      v7 = *v6;
      a1[10] = ++v2;
      switch ( v7 )
      {
        case 35:
          if ( !a1[6] )
            goto LABEL_20;
          break;
        case 47:
          if ( !a1[6] )
          {
            if ( v4 != 1 )
            {
              v4 = 1;
              goto LABEL_13;
            }
LABEL_20:
            v5 = 1;
            goto LABEL_13;
          }
          break;
        case 10:
          v5 = a1[6];
          v9 = a1[15];
          a1[16] = 1;
          a1[15] = v9 + 1;
          if ( v5 )
            goto LABEL_18;
LABEL_17:
          if ( (unsigned int)(v7 - 9) > 1 )
          {
LABEL_18:
            a1[4] = v7;
            return v7;
          }
          v2 = a1[10];
          v4 = 0;
          goto LABEL_13;
      }
      ++a1[16];
      if ( v5 == 1 )
      {
        v4 = 0;
      }
      else
      {
        if ( a1[6] )
          goto LABEL_18;
        v8 = v7 == 32;
        if ( v7 != 32 )
          v8 = v7 == 13;
        if ( !v8 )
          goto LABEL_17;
        v4 = a1[6];
        v2 = a1[10];
      }
LABEL_13:
      ++v6;
      if ( v2 == a1[9] )
      {
LABEL_14:
        if ( sub_21C4((int)a1) == -1 )
        {
          a1[4] = 0;
          return 0;
        }
        v6 = (char *)a1[7];
        v2 = a1[10];
      }
    }
  }
  v11 = a1[4];
  a1[5] = 0;
  return v11;
}

//----- (000022B8) --------------------------------------------------------
int __fastcall sub_22B8(_DWORD *a1, _BYTE *a2)
{
  char v4; // r0

  while ( 1 )
  {
    v4 = sub_21EC(a1);
    *a2 = v4;
    if ( !v4 )
      break;
    if ( v4 != 32 )
      return 0;
  }
  return 1;
}

//----- (000022D8) --------------------------------------------------------
int __fastcall sub_22D8(int *a1, int a2)
{
  int v2; // r5
  int v3; // r7
  int *v4; // r4
  int v5; // r3
  int v6; // r2
  int v7; // r0

  v4 = (int *)a1[4];
  if ( a2 > 0 )
  {
    v3 = a2;
    v2 = 0;
  }
  *(_BYTE *)*a1 = (_BYTE)v4;
  if ( a2 > 0 )
    v4 = a1;
  a1[3] = 1;
  if ( a2 <= 0 )
    return 0;
  while ( 1 )
  {
    ++v2;
    v7 = sub_21EC(v4);
    if ( !v7 )
      break;
    v5 = v4[3];
    v6 = *v4;
    v4[3] = v5 + 1;
    *(_BYTE *)(v6 + v5) = v7;
    if ( v2 == v3 )
      return 0;
  }
  return 1;
}
// 2304: variable 'v3' is possibly undefined
// 2308: variable 'v2' is possibly undefined

//----- (0000231C) --------------------------------------------------------
void *__fastcall sub_231C(int a1, int a2)
{
  size_t v3; // r9
  int v5; // r6
  int v6; // r4
  void *v7; // r0
  void *i; // r8
  void *v9; // r5

  v3 = *(_DWORD *)(a1 + 8);
  v5 = *(_DWORD *)(a1 + 4);
  v6 = v3 + v5;
  v7 = malloc(v3 + v5);
  for ( i = v7; a2 > v6; v6 += v5 )
    ;
  v9 = *(void **)a1;
  memcpy(v7, *(const void **)a1, v3);
  free(v9);
  *(_DWORD *)a1 = i;
  *(_DWORD *)(a1 + 8) = v6;
  return i;
}

//----- (00002360) --------------------------------------------------------
int __fastcall sub_2360(int a1, const char *a2)
{
  char s[1024]; // [sp+Ch] [bp-41Ch] BYREF

  sprintf(s, "error on pos %d in line %d, reason=%s", *(_DWORD *)(a1 + 64) - 1, *(_DWORD *)(a1 + 60), a2);
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 88) = 1;
  *(_DWORD *)(a1 + 72) = s;
  return (*(int (__fastcall **)(int, _DWORD))(a1 + 80))(a1 + 56, *(_DWORD *)(a1 + 92));
}

//----- (000023C0) --------------------------------------------------------
int __fastcall sub_23C0(char **a1)
{
  char *v2; // r1
  int v3; // r10
  int v4; // r6
  char *v5; // r5
  char *v6; // r3
  char v7; // r11
  char *v8; // r9
  int v9; // r2
  int v10; // r3
  char *v11; // r0
  bool v12; // zf
  char *v13; // r2
  char *v14; // r2
  int result; // r0
  char *v16; // r0

  v2 = a1[10];
  v3 = 0;
  v4 = 0;
  v5 = *a1;
  v6 = &v2[(_DWORD)a1[7]];
  if ( a1[9] == v2 )
    goto LABEL_21;
  while ( 1 )
  {
    do
    {
      v7 = *v6;
      ++v2;
      v8 = v6 + 1;
      a1[10] = v2;
      v9 = v7;
      if ( v7 == 92 )
      {
        if ( !v4 )
        {
          v4 = 1;
          ++a1[16];
          ++v6;
          continue;
        }
        v11 = v5;
      }
      else
      {
        if ( v7 == 117 )
          v10 = v4 & 1;
        else
          v10 = 0;
        v11 = v5;
        if ( v10 )
        {
          if ( ++v3 >= (int)a1[2] )
          {
            v16 = (char *)sub_231C((int)a1, v3);
            v9 = v7;
            v5 = &v16[v3 - 1];
          }
          v11 = v5 + 1;
          *v5 = 92;
        }
        if ( v9 == 34 )
        {
          if ( !v4 )
          {
            *v11 = 0;
            return 0;
          }
          v4 = 0;
        }
        else
        {
          v12 = v9 == 10;
          if ( v9 == 10 )
          {
            a1[16] = (_BYTE *)(&dword_0 + 1);
            v13 = a1[15];
          }
          else
          {
            v13 = a1[16];
          }
          v4 = 0;
          v14 = v13 + 1;
          if ( v12 )
            a1[15] = v14;
          else
            a1[16] = v14;
        }
      }
      if ( ++v3 >= (int)a1[2] )
        v11 = (char *)sub_231C((int)a1, v3) + v3 - 1;
      *v11 = v7;
      v5 = v11 + 1;
      v2 = a1[10];
      v6 = v8;
    }
    while ( a1[9] != v2 );
LABEL_21:
    if ( sub_21C4((int)a1) == -1 )
      break;
    v6 = a1[7];
    v2 = a1[10];
  }
  result = 1;
  a1[4] = 0;
  return result;
}
// 0: using guessed type int dword_0;

//----- (000024B0) --------------------------------------------------------
int __fastcall sub_24B0(char **a1)
{
  char *v2; // r4
  char *v3; // r1
  int v4; // r3
  char **v5; // r9
  int v6; // r4
  int v7; // r10
  bool v8; // zf
  int v10; // r3
  int v11; // r3
  int v12; // r3
  int v13; // r3
  int v14; // [sp+4h] [bp-34h]
  char v15; // [sp+Ah] [bp-2Eh] BYREF
  char v16; // [sp+Bh] [bp-2Dh] BYREF
  int v17; // [sp+Ch] [bp-2Ch]

  v2 = a1[20];
  v3 = a1[23];
  v4 = _stack_chk_guard;
  a1[14] = (_BYTE *)(&dword_0 + 3);
  v5 = a1 + 14;
  v17 = v4;
  if ( ((int (__fastcall *)(char **, char *))v2)(a1 + 14, v3) )
  {
    sub_2360((int)a1, "aborted by user callback");
    return 1;
  }
  else
  {
    v6 = 0;
    v7 = sub_22B8(a1, &v15);
    if ( v7 )
    {
LABEL_23:
      sub_2360((int)a1, "'}' or value expected");
      return v7;
    }
    else
    {
      while ( 1 )
      {
        v8 = v6 == 0;
        if ( !v6 )
          v8 = v15 == 125;
        if ( v8 )
          break;
        if ( v15 != 34 )
        {
          v7 = 1;
          sub_2360((int)a1, "value expected");
          return v7;
        }
        v10 = sub_23C0(a1);
        if ( v10 )
        {
          v7 = v10;
          sub_2360((int)a1, "unexpected end of stream while getting a key");
          return v7;
        }
        if ( !**a1 )
        {
          v7 = 1;
          sub_2360((int)a1, "key must not be an empty string");
          return v7;
        }
        a1[18] = *a1;
        a1[14] = &byte_7;
        if ( ((int (__fastcall *)(char **, char *))a1[20])(v5, a1[23]) )
          goto LABEL_12;
        v11 = sub_22B8(a1, &v16);
        if ( !v11 && v16 == 58 )
        {
          v12 = sub_2660(a1);
        }
        else
        {
          v14 = v11;
          sub_2360((int)a1, "missing ':'");
          v12 = v14;
        }
        if ( v12 )
          return v12;
        v13 = sub_22B8(a1, &v15);
        if ( v13 )
        {
          v7 = v13;
          sub_2360((int)a1, "syntax error, expected '}' or ','");
          return v7;
        }
        if ( v15 == 125 )
          break;
        ++v6;
        v7 = sub_22B8(a1, &v15);
        if ( v7 )
          goto LABEL_23;
      }
      a1[14] = &byte_4;
      if ( ((int (__fastcall *)(char **, char *))a1[20])(v5, a1[23]) )
      {
LABEL_12:
        v7 = 1;
        sub_2360((int)a1, "aborted by user callback");
      }
      return v7;
    }
  }
}
// 0: using guessed type int dword_0;
// 4: using guessed type char byte_4;
// 7: using guessed type char byte_7;

//----- (00002660) --------------------------------------------------------
int __fastcall sub_2660(char **a1)
{
  char v2; // r0
  unsigned int v3; // r3
  bool v4; // cc
  int v5; // r5
  int result; // r0
  char *v7; // r3
  char *v8; // r5
  int v9; // r6
  int v10; // r0
  int v11; // r3
  char *v12; // r3
  char *v13; // r3
  char *v14; // r3

  v2 = sub_21EC(a1);
  switch ( v2 )
  {
    case 0:
      sub_2360((int)a1, "unexpected end of stream while getting a value");
      return 1;
    case 123:
      a1[5] = 0;
      return sub_24B0(a1);
    case 91:
      a1[5] = 0;
      return sub_2850(a1);
  }
  v3 = (unsigned int)a1[4];
  switch ( v3 )
  {
    case '"':
      v5 = 1;
      a1[6] = (_BYTE *)(&dword_0 + 1);
      if ( !sub_23C0(a1) )
      {
        v5 = 0;
        a1[14] = &byte_8;
      }
      v7 = *a1;
      a1[6] = 0;
      a1[18] = v7;
      if ( v5 )
        goto LABEL_13;
      goto LABEL_18;
    case 't':
      if ( !sub_22D8((int *)a1, 3) )
      {
        v12 = *a1;
        if ( **a1 == 116 && v12[1] == 114 && v12[2] == 117 && v12[3] == 101 )
        {
          a1[14] = byte_9;
          goto LABEL_18;
        }
      }
LABEL_12:
      v5 = 1;
LABEL_13:
      sub_2360((int)a1, "failed to retrieve concrete value");
      return v5;
    case 'f':
      if ( !sub_22D8((int *)a1, 4) )
      {
        v13 = *a1;
        if ( **a1 == 102 && v13[1] == 97 && v13[2] == 108 && v13[3] == 115 && v13[4] == 101 )
        {
          v11 = 10;
LABEL_32:
          a1[14] = (char *)v11;
          goto LABEL_18;
        }
      }
      goto LABEL_12;
  }
  if ( v3 != 110 )
  {
    v4 = v3 > 0x2D;
    if ( v3 != 45 )
      v4 = v3 - 48 > 9;
    if ( !v4 )
    {
      v8 = *a1;
      v9 = 0;
      a1[5] = (_BYTE *)(&dword_0 + 1);
      while ( 1 )
      {
        while ( 1 )
        {
          v10 = sub_21EC(a1);
          if ( !v10 )
            goto LABEL_12;
          if ( (unsigned int)(v10 - 48) > 9 )
            break;
LABEL_27:
          *v8++ = v10;
        }
        if ( v10 != 46 )
        {
          if ( v10 <= 46 )
          {
            if ( v10 != 43 && v10 != 45 )
              goto LABEL_30;
            goto LABEL_27;
          }
          if ( v10 != 69 && v10 != 101 )
          {
LABEL_30:
            *v8 = 0;
            a1[5] = (_BYTE *)(&dword_0 + 1);
            if ( v9 )
            {
              sscanf(*a1, "%lf", a1 + 18);
              v11 = 13;
            }
            else
            {
              sscanf(*a1, "%lld", a1 + 18);
              v11 = 12;
            }
            goto LABEL_32;
          }
        }
        *v8 = v10;
        v9 = 1;
        ++v8;
      }
    }
    goto LABEL_12;
  }
  if ( sub_22D8((int *)a1, 3) )
    goto LABEL_12;
  v14 = *a1;
  if ( **a1 != 110 || v14[1] != 117 || v14[2] != 108 || v14[3] != 108 )
    goto LABEL_12;
  a1[14] = byte_9 + 2;
LABEL_18:
  result = ((int (__fastcall *)(char **, char *))a1[20])(a1 + 14, a1[23]);
  if ( result )
  {
    sub_2360((int)a1, "aborted by user callback");
    return 1;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 8: using guessed type char;

//----- (00002850) --------------------------------------------------------
int __fastcall sub_2850(_DWORD *a1)
{
  int (__fastcall *v2)(_DWORD *, int); // r4
  int v3; // r3
  int v4; // r1
  _DWORD *v5; // r10
  int v6; // r6
  int v7; // r4
  int result; // r0
  int (__fastcall *v9)(_DWORD *, _DWORD); // r3
  int (__fastcall *v10)(_DWORD *, _DWORD); // r3
  char v11; // [sp+3h] [bp-25h] BYREF
  int v12; // [sp+4h] [bp-24h]

  v2 = (int (__fastcall *)(_DWORD *, int))a1[20];
  v3 = _stack_chk_guard;
  v4 = a1[23];
  a1[14] = 5;
  v5 = a1 + 14;
  v12 = v3;
  if ( !v2(a1 + 14, v4) )
  {
    v6 = 0;
    a1[11] = 1;
    while ( 1 )
    {
      if ( !v6 )
      {
        v7 = sub_22B8(a1, &v11);
        if ( v7 )
        {
          sub_2360((int)a1, "failed to retrieve concrete value");
          goto LABEL_8;
        }
        if ( v11 == 93 )
        {
          v9 = (int (__fastcall *)(_DWORD *, _DWORD))a1[20];
          a1[14] = 6;
          if ( v9(v5, a1[23]) )
          {
            v7 = 1;
            sub_2360((int)a1, "aborted by user callback");
            goto LABEL_8;
          }
          goto LABEL_16;
        }
        a1[5] = 1;
      }
      v7 = sub_2660((int)a1);
      if ( v7 )
        goto LABEL_8;
      ++v6;
      if ( sub_22B8(a1, &v11) == 1 )
      {
LABEL_13:
        v7 = 1;
        sub_2360((int)a1, "syntax error, expected ']' or ','");
LABEL_8:
        result = v7;
        a1[11] = 0;
        return result;
      }
      if ( v11 == 93 )
        break;
      if ( v11 != 44 )
        goto LABEL_13;
    }
    v10 = (int (__fastcall *)(_DWORD *, _DWORD))a1[20];
    a1[14] = 6;
    if ( !v10(v5, a1[23]) )
    {
LABEL_16:
      v7 = 0;
      goto LABEL_8;
    }
  }
  sub_2360((int)a1, "aborted by user callback");
  return 1;
}

//----- (00002954) --------------------------------------------------------
_DWORD *__fastcall esojson_parser_create(int a1, int a2, int a3, size_t a4, int a5)
{
  _DWORD *v9; // r4
  void *v10; // r0
  void *v11; // r0

  v9 = malloc(0x60u);
  v9[20] = a1;
  v9[21] = a2;
  v10 = malloc(a3 + 1);
  v9[8] = a3;
  v9[2] = a4;
  v9[1] = a4;
  v9[7] = v10;
  v11 = malloc(a4);
  v9[23] = a5;
  v9[9] = 0;
  v9[10] = 0;
  v9[22] = 0;
  *v9 = v11;
  return v9;
}

//----- (00002998) --------------------------------------------------------
void __fastcall esojson_parser_destroy(void **a1)
{
  if ( a1 )
  {
    free(a1[7]);
    free(*a1);
    j_free(a1);
  }
}

//----- (000029B8) --------------------------------------------------------
int __fastcall esojson_parser_parse(int a1)
{
  int v2; // r5
  int v3; // r7
  int v4; // r1
  char v5; // r3
  void (__fastcall *v6)(int, _DWORD); // r3
  char v8; // [sp+3h] [bp-1Dh] BYREF

  v2 = 2;
  if ( a1 )
  {
    v3 = a1 + 56;
    v2 = 1;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 48) = 0;
    v4 = *(_DWORD *)(a1 + 92);
    *(_DWORD *)(a1 + 60) = 1;
    *(_DWORD *)(a1 + 64) = 1;
    *(_DWORD *)(a1 + 56) = 1;
    (*(void (__fastcall **)(int, int))(a1 + 80))(a1 + 56, v4);
    if ( sub_22B8((_DWORD *)a1, &v8) )
    {
      sub_2360(a1, "'{' or '[' expected");
      goto LABEL_6;
    }
    v5 = v8;
    *(_DWORD *)(a1 + 20) = 0;
    if ( v5 == 123 )
    {
      v2 = sub_24B0((char **)a1);
    }
    else
    {
      if ( v5 != 91 )
      {
LABEL_5:
        v2 = 1;
        sub_2360(a1, "'{' or '[' expected");
LABEL_6:
        v6 = *(void (__fastcall **)(int, _DWORD))(a1 + 80);
        *(_DWORD *)(a1 + 56) = 2;
        v6(v3, *(_DWORD *)(a1 + 92));
        return v2;
      }
      v2 = sub_2850((_DWORD *)a1);
    }
    if ( !v2 )
    {
      if ( sub_22B8((_DWORD *)a1, &v8) != 1 )
      {
        v2 = 1;
        sub_2360(a1, "EOF expected");
      }
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  return v2;
}

//----- (00002A88) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=112 queued=36 decompiled=36 lumina nreq=0 worse=0 better=0
// ALL OK, 36 function(s) have been successfully decompiled
